###MakeFile学习笔记
1. 编译器需要的是语法的正确，函数与变量的声明的正确。对于链接，通常是你需要
告诉编译器头文件的所在位置
2. 编译器只检测程序语法，和函数、变量是否被声明
3. 在链接程序时，链接器会在所有的 Object File 中
找寻函数的实现，如果找不到，那到就会报链接错误码（ Linker Error） 
4. make 命令执行时，需要一个 Makefile 文件，以告诉 make 命令需要怎么样的去编译和链
接程序
#####MakeFile的书写规则
1. 如果这个工程没有编译过，那么我们的所有 C 文件都要编译并被链接。
2. 如果这个工程的某几个 C 文件被修改，那么我们只编译被修改的 C 文件，并链接目
标程序。
3. 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的 C 文件，
并链接目标程序。
make
命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所
需要的文件和链接目标程序。
####MakeFile规则
```
target ... : prerequisites ...      //target 也就是一个目标文件，可以是 Object File，也可以是执行文件。还可以是
一个标签（ Label）                   //prerequisites 就是，要生成那个 target 所需要的文件或是目标
command                             //command 也就是 make 需要执行的命令。（任意的 Shell 命令）
...
...
```
4. 反斜杠（ \）是换行符的意思
5. 依赖关系的实质上
就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。
6.  makefile 中以“ $(objects)”的方式来使用这个变
量了
####让make自动推导
* make可以自动推导文件以及文件依赖关系后面的命令，make会自动识别，并自己推导
命令
*  make的隐晦规则, .PHONY表示, clean是个伪目标文件。
*  每个 Makefile 中都应该写一个清空目标文件（ .o 和执行文件）的规则，这不仅便于重编
译，也很利于保持文件的清洁。
* 在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。
*  clean 从来都是放在文件的最后
####MakeFile中主要包含5样东西: 显示规则、隐晦规则、变量定义、文件指示和注释。
1. 显示规则。
* 显示规则说明了，如何生成一个或多的的目标文件。这是由 Makefile 的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。
2. 隐晦规则。
* 由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。
3. 变量的定义。
* 在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。
4. 文件指示。
* 其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像 C 语言中的 include 一样；
* 另一个是指根据某些情况指定 Makefile 中的有效部分，就像 C 语言中的预编译#if 一样；
* 还有就是定义一个多行的命令。
5. 注释。 
* Makefile 中只有行注释，和 UNIX 的 Shell 脚本一样，其注释是用`#`字符，
这个就像 C/C++中的`//`一样。
* 如果你要在你的Makefile中使用`#`字符，可以用反斜框进行转义，如：`\#`。
6. 最后，还值得一提的是，在 Makefile 中的命令，必须要以[Tab]键开始。    

* 默认的情况 下， make 命令会在当 前目录下按 顺序找寻文 件名为`GNUmakefile`、
`makefile`、 `Makefile`的文件，找到了解释这个文件。

####引用其他的MakeFile
* 在 Makefile 使用 include 关键字可以把别的 Makefile 包含进来
* `include <filename>` 其中`filename`可以是当前操作系统`Shell`的文件模式（可以保含路径和通配符）
* make 会在当前目录下首先寻找，如果当前目录下没有找到，那么， make 还会在下面的几个目录下找：
    1. 如果 make 执行时，有`-I`或`--include-dir`参数，那么make就会在这个参数所指定的目录下去寻找。
    2. 如果目录`<prefix>/include`（一般是：`/usr/local/bin`或`/usr/include`）
存在的话， make 也会去找。
* `makefile`中的减号`-`表示执行过程中出现什么错误，都不要报错继续执行。
* 环境变量 `MAKEFILES`, 如果系统存在，则所有都会受他的影响
* 书写规则-规则包含两个部分，一个是依赖关系，一个是生成目标的方法
    - 一定要让 make 知道你的最终目标是什么
* 在规则中使用通配符----make支持三个通配符：`*`，`?`和`[...]`
* “伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以 make 无法生成它的依赖关系和决定它是否要执行。
*  .PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。
*  伪目标同样也可成为依赖。
*  使用一个自动化变量`$<`和`$@`则是自动化变量, `$<`表示所有的依赖目标集(比如`foo.c bar.c`), `$@`表示目标集(比如`foo.o bar.o`)
*  利用编译器的`-M`的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系, GNU 的 C/C++编译器的`-M`会把一些标准库的头文件也包含进来, 应该用`-MM`选项
*  [.d]文件中就存放对应[.c]文件的依赖关系。
*  make 会一按顺序一条一条的执行命令，每条命令的开头必须以[Tab]键开头
*  在命令前加上@, 不会显示命令, `-s`或`--slient`则是全面禁止命令的显示。
*  用分号表示语句的依赖
*  给 make 加上“ -i”或是“ --ignore-errors”参数，那么，Makefile 中所有命令都会忽略错误
*  一个是 SHELL，一个是 MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层 Makefile 中
```
define run-yacc             #定义命令包
yacc $(firstword $^)
mv y.tab.c $@
endef
```

####自动化变量极其说明:
1. $@:
    表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，`$@`就是匹配于目标中模式定义的集合。
2. $%:
    仅当 目 标是函数库 文件中，表 示规则中的 目标成员名 。
3. $<:
    依赖目标中的第一个目标名字。如果依赖目标是以模式（即`%`）定义的，那么`$<`, 将是符合模式的一系列的文件集。
4. $?:
    所有比目标新的依赖目标的集合。以空格分隔。
5. $^:
    所有的依赖目标的集合。会去除重复的依赖目标, 只保留一份。
6. $+：
    所有的依赖目标的集合。不去除重复的依赖目标。
7. $*:
    这个变量表示目标模式中“ %”及其之前的部分。
* `%`代表一个或多个字符。